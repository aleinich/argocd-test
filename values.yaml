common_storage: &storage_size "5Gi"

# Regola di Anti-Affinity: impedisce a pod con la stessa label di stare sullo stesso nodo
node1:
  fullnameOverride: "vm-node1"
  server:
    annotations: 
      argocd.argoproj.io/sync-wave: "1"
    persistentVolume: { enabled: true, size: *storage_size }
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/instance
              operator: In
              values: ["vm-node1", "vm-node2"]
          topologyKey: "kubernetes.io/hostname"
  vmagent: { enabled: false }

node2:
  fullnameOverride: "vm-node2"
  server:
    annotations: 
      argocd.argoproj.io/sync-wave: "2"
    persistentVolume: { enabled: true, size: *storage_size }
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/instance
              operator: In
              values: ["vm-node1", "vm-node2"]
          topologyKey: "kubernetes.io/hostname"
  vmagent: { enabled: false }

vmauth:
  enabled: true
  fullnameOverride: "vm-gateway"
  replicaCount: 2
  annotations: 
    argocd.argoproj.io/sync-wave: "3"
  
  # Anti-Affinity per il gateway: distribuisce le 2 repliche sui 2 nodi
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values: ["vmauth"]
        topologyKey: "kubernetes.io/hostname"

  updateStrategy:
      type: RollingUpdate
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0

  config:
    # Solo accesso non autenticato (Pass-through totale)
    unauthorized_user:
      url_prefix: 
        - "http://vm-node1-server:8428"
        - "http://vm-node2-server:8428"
